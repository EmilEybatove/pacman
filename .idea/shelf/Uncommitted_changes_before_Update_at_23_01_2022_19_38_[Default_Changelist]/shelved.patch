Index: functions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport sys\r\nfrom collections import deque\r\nfrom pprint import pprint\r\nfrom random import sample, choice, random\r\nimport pygame\r\nfrom pygame import Color\r\nimport threading\r\nfrom math import sqrt\r\n\r\n\r\nall_sprites = pygame.sprite.Group()\r\ntiles_group = pygame.sprite.Group()\r\nbase_group = pygame.sprite.Group()\r\nplayer_group = pygame.sprite.Group()\r\nhunter_group = pygame.sprite.Group()\r\npause_group = pygame.sprite.Group()\r\nTILE = tile_width = tile_height = 18\r\nSCRIPT_PATH = None\r\nif os.name == \"nt\":\r\n    SCRIPT_PATH = os.getcwd()\r\nelse:\r\n    SCRIPT_PATH = sys.path[0]\r\n\r\nghostGate = [(10, 12), (11, 12), (12, 12), (13, 12), (14, 12), (15, 12),\r\n             (10, 13), (11, 13), (12, 13), (13, 13), (14, 13), (15, 13)]\r\n# GONNA WORK ONLY FOR DEFAULT MAP!!\r\nghost_color = [Color(255, 0, 0, 255),  # Red\r\n               Color(255, 128, 255, 255),  # pink\r\n               Color(128, 255, 255, 255),  # light blue\r\n               Color(255, 128, 0, 255),  # orange\r\n               Color(50, 50, 255, 255),  # blue vulnerable\r\n               Color(255, 255, 255, 255)]  # white\r\n\r\ncols, rows = 26, 26\r\n\r\n\r\ndef load_image(name, colorkey=None):\r\n    fullname = os.path.join('data', name)\r\n    if not os.path.isfile(fullname):\r\n        print(f\"Файл с изображением '{fullname}' не найден\")\r\n        sys.exit()\r\n    image = pygame.image.load(fullname)\r\n    if colorkey is not None:\r\n        image = image.convert()\r\n        if colorkey == -1:\r\n            colorkey = image.get_at((0, 0))\r\n        image.set_colorkey(colorkey)\r\n    return image\r\n\r\n\r\ntile_images = {\r\n    'vertical': load_image('vertical.png'),\r\n    'horisontal': load_image('horisontal.png'),\r\n    '1': load_image('1.png'),\r\n    '2': load_image('2.png'),\r\n    '3': load_image('4.png'),\r\n    '4': load_image('3.png'),\r\n    'empty': load_image('empty.png'),\r\n    'point': load_image('point.png'),\r\n    'energo': load_image('energo.png'),\r\n    'gate': load_image('gate.png')}\r\n\r\nvalues = {\r\n    '|': 'vertical',\r\n    '-': 'horisontal',\r\n    '1': '1',\r\n    '2': '2',\r\n    '3': '3',\r\n    '4': '4',\r\n    '.': 'empty',\r\n    '@': 'pacman',\r\n    '*': 'energo',\r\n    '0': 'point',\r\n    '?': 'gate'\r\n}\r\n\r\n\r\nclass Tile(pygame.sprite.Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y, groups=(tiles_group, all_sprites)):\r\n        super().__init__(*groups)\r\n        self.cords = [pos_x, pos_y]\r\n        self.image = tile_images[tile_type]\r\n        self.rect = self.image.get_rect().move(\r\n            tile_width * pos_x, tile_height * pos_y)\r\n\r\n\r\ndef get_rect(x, y):\r\n    return x * TILE + 1, y * TILE + 1, TILE - 2, TILE - 2\r\n\r\n\r\ndef load_image(name, colorkey=None):\r\n    if SCRIPT_PATH:\r\n        fullname = os.path.join(SCRIPT_PATH, 'data', name)\r\n    else:\r\n        fullname = os.path.join('data', name)\r\n\r\n    if not os.path.isfile(fullname):\r\n        print(f\"Файл с изображением '{fullname}' не найден\")\r\n        sys.exit()\r\n    image = pygame.image.load(fullname)\r\n    if colorkey is not None:\r\n        image = image.convert()\r\n        if colorkey == -1:\r\n            colorkey = image.get_at((0, 0))\r\n        image.set_colorkey(colorkey)\r\n    return image\r\n\r\n\r\nclass Hunter(pygame.sprite.Sprite):\r\n    def __init__(self, sprite_group, row, col, grid, color_ind):\r\n        super().__init__(sprite_group)\r\n        self.grid = grid\r\n        self.row = row\r\n        self.col = col\r\n        self.color = color_ind\r\n        self.attacked = False\r\n        self.dead = False\r\n        self.counter = 0\r\n        self.path = []\r\n        self.start_pos = [row, col]\r\n        try:\r\n            self.frame = 0\r\n            self.anim = {}\r\n            for i in range(6):\r\n                self.anim[i] = load_image(os.path.join(\"ghost_sprites\", \"ghost_\" + str(i) + \".gif\"))\r\n            self.color_frames(ghost_color[0], ghost_color[self.color])\r\n            self.image = self.anim[0]\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x, self.rect.y, *_ = get_rect(self.row, self.col)\r\n        except FileNotFoundError:\r\n            self.image = pygame.Surface((TILE, TILE))\r\n            self.image.fill(pygame.Color(\"green\"))\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x, self.rect.y, *_ = get_rect(self.row, self.col)\r\n        # Usual code\r\n        self.restricted = [\"|\", \"-\", \"1\", \"2\", \"3\", \"4\", 1, 2, 3, 4]\r\n        self.allowed = [\"0\", 0, \".\", \"*\", \"?\"]\r\n        self.graph = {}\r\n        for y, row in enumerate(grid):\r\n            for x, col in enumerate(row):\r\n                if col in self.allowed:\r\n                    self.graph[(x, y)] = self.graph.get((x, y), []) + self.get_next_nodes(x, y)\r\n                else:\r\n                    self.graph[(x, y)] = []\r\n\r\n    def new(self):\r\n        self.row = self.start_pos[0]\r\n        self.col = self.start_pos[1]\r\n        self.rect.x = self.start_pos[0] * TILE\r\n        self.rect.y = self.start_pos[1] * TILE\r\n        self.counter = 0\r\n        self.setDead(False)\r\n        self.setAttacked(False)\r\n\r\n    def color_frames(self, from_color: Color, to_color: Color):\r\n        for i in range(6):\r\n            palette = list(self.anim[i].get_palette())\r\n            for j, c in enumerate(palette):\r\n                if c == from_color:\r\n                    palette[j] = to_color\r\n            self.anim[i].set_palette(palette)\r\n\r\n    def move(self, goal):\r\n        if goal and self.graph[goal]:\r\n            if self.attacked:\r\n                self.color_frames(ghost_color[self.color], ghost_color[4])\r\n                distances = {}\r\n                for node in self.get_next_nodes(self.row, self.col):\r\n                    distances[node] = sqrt((node[0] - goal[0]) ** 2 + (node[1] - goal[1]) ** 2)\r\n                for el in distances.keys():\r\n                    if distances[el] == max(distances.values()) and random() <= 0.8:\r\n                        real_goal = el\r\n                    else:\r\n                        real_goal = choice([el for el in self.graph if self.graph[el]])\r\n            if self.dead:\r\n                self.color_frames(ghost_color[4], Color(0, 0, 0, 255))\r\n                if (self.row, self.col) in ghostGate:\r\n                    self.setDead(False)\r\n                real_goal = choice(ghostGate)\r\n            if not self.attacked and not self.dead:\r\n                self.color_frames(Color(0, 0, 0, 255), ghost_color[self.color])\r\n                self.color_frames(ghost_color[4], ghost_color[self.color])\r\n                real_goal = goal\r\n            if self.counter == 0:\r\n                self.row, self.col = int(self.rect.x / 18), int(self.rect.y / 18)\r\n                self.path = self.find_path((self.row, self.col), real_goal)\r\n            self.counter = (self.counter + 1) % 18\r\n            self.frame = (self.frame + 1) % 6\r\n            self.image = self.anim[self.frame]\r\n            # print(f\"We are now at position {self.row, self.col} and gonna go to {goal}\")\r\n            # print(f\"Our path is {self.path}\")\r\n\r\n            if self.path and len(self.path) > 1:\r\n                final_goal = self.path[1]\r\n                if  self.row < final_goal[0]:\r\n                    self.rect.x += 1\r\n                elif self.row > final_goal[0]:\r\n                    self.rect.x -= 1\r\n                elif self.col < final_goal[1]:\r\n                    self.rect.y += 1\r\n                elif self.col > final_goal[1]:\r\n                    self.rect.y -= 1\r\n\r\n    def get_next_nodes(self, x, y):\r\n        check_node = lambda x, y: True if (0 <= x < cols) and (0 <= y < rows) and \\\r\n                                          (self.grid[y][x] in self.allowed) else False\r\n        ways = [0, -1], [0, 1], [1, 0], [-1, 0]\r\n        return [(x + dx, y + dy) for dx, dy in ways if check_node(x + dx, y + dy)]\r\n\r\n    def cleanup(self):\r\n        self.parent = dict()\r\n        self.queue = \"\"\r\n        self.node = \"\"\r\n        self.path = []\r\n\r\n    def find_path(self, start_point, end_point):\r\n        self.cleanup()\r\n        self.parent, self.queue = {start_point: None}, deque([start_point])\r\n\r\n        if start_point not in self.graph:\r\n            raise ValueError(\"Start point is not in graph\")\r\n        if end_point not in self.graph:\r\n            raise ValueError(\"End point is not in graph\")\r\n        while self.queue:\r\n            self.node = self.queue.popleft()\r\n            for neighbour in self.graph[self.node]:\r\n                if self.node == end_point:\r\n                    self.path = [self.node]\r\n                    n = self.parent.get(self.node)\r\n                    while n is not None:\r\n                        self.path.append(n)\r\n                        n = self.parent.get(n)\r\n                    # print(self.path[::-1])\r\n                    return self.path[::-1]\r\n                if neighbour not in self.parent:\r\n                    self.queue.append(neighbour)\r\n                    self.parent[neighbour] = self.node\r\n        return None\r\n\r\n    def setAttacked(self, isAttacked):\r\n        self.attacked = isAttacked\r\n\r\n    def isAttacked(self):\r\n        return self.attacked\r\n\r\n    def setDead(self, isDead):\r\n        self.dead = isDead\r\n        print(self.dead)\r\n\r\n    def isDead(self):\r\n        return self.dead\r\n\r\n    def collides(self):\r\n        # print(pygame.sprite.spritecollideany(self, player_group))\r\n        pass\r\n\r\n\r\n\r\n\r\ndef load_image_pacman(name, colorkey=None):\r\n    fullname = os.path.join('data/pacman_sprites', name)\r\n    if not os.path.isfile(fullname):\r\n        print(f\"Файл с изображением '{fullname}' не найден\")\r\n        sys.exit()\r\n    image = pygame.image.load(fullname)\r\n    if colorkey is not None:\r\n        image = image.convert()\r\n        if colorkey == -1:\r\n            colorkey = image.get_at((0, 0))\r\n        image.set_colorkey(colorkey)\r\n    return image\r\n\r\n\r\n# преобразование текстового файла в список спрайтов\r\ndef load_level(filename):\r\n    filename = \"levels/\" + filename\r\n    with open(filename, 'r') as mapFile:\r\n        level_map = [line.strip() for line in mapFile]\r\n    max_width = max(map(len, level_map))\r\n    return list(map(lambda x: x.ljust(max_width, '.'), level_map))\r\n\r\n\r\n# создание уровня\r\ndef generate_level(level):\r\n    global base_group, cols, rows\r\n    points = 0\r\n    rows = len(level)\r\n    cols = len(level[0])\r\n    new_player, x, y, pacman_pos = None, None, None, None\r\n    for y in range(len(level)):\r\n        for x in range(len(level[y])):\r\n            if level[y][x] == '@':\r\n                Tile('empty', x, y)\r\n                new_player = Player(x, y)\r\n                pacman_pos = [x, y]\r\n            elif level[y][x] in list(values.keys()):\r\n                if level[y][x] in ['0', '*']:\r\n                    points += 1\r\n                Tile(values[level[y][x]], x, y)\r\n\r\n    return new_player, x, y, pacman_pos, points\r\n\r\n\r\ndef terminate():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n# оформление стартового окна\r\ndef print_intro():\r\n    screen.fill('black')\r\n    pygame.display.set_caption('play pacman')\r\n    pygame.draw.rect(screen, 'yellow', (100, 300, 300, 50), 1)\r\n    pygame.display.flip()\r\n    intro_text = [\"Welcome to\", \"PACMAN\",\r\n                  \"Введите название своего уровня\", \"или\", \"сразу нажмите Enter для начала игры\"]\r\n    font = pygame.font.Font(None, 40)\r\n    string_rendered = font.render(intro_text[0], 1, pygame.Color('yellow'))\r\n    intro_rect = string_rendered.get_rect()\r\n    intro_rect.top = 50\r\n    intro_rect.x = 250 - intro_rect.width // 2\r\n    screen.blit(string_rendered, intro_rect)\r\n    font = pygame.font.Font(None, 80)\r\n    string_rendered = font.render(intro_text[1], 3, pygame.Color('yellow'))\r\n    intro_rect = string_rendered.get_rect()\r\n    intro_rect.top = 80\r\n    intro_rect.x = 250 - intro_rect.width // 2\r\n    screen.blit(string_rendered, intro_rect)\r\n    font = pygame.font.Font(None, 20)\r\n    for i in range(2, 5):\r\n        string_rendered = font.render(intro_text[i], 1, pygame.Color('yellow'))\r\n        intro_rect = string_rendered.get_rect()\r\n        intro_rect.top = 250 + 15 * (i - 2)\r\n        intro_rect.x = 250 - intro_rect.width // 2\r\n        screen.blit(string_rendered, intro_rect)\r\n    picture = pygame.transform.scale(load_image('intro_picture.jpg'), (300, 70))\r\n    screen.blit(picture, (100, 400))\r\n\r\n\r\n# отображение ввода текста пользователем в окне\r\ndef print_text(text):\r\n    font = pygame.font.Font(None, 40)\r\n    text_coord = 310\r\n    pygame.draw.rect(screen, 'black', (105, 305, 290, 40), 0)\r\n    string_rendered = font.render(text, 20, pygame.Color('yellow'))\r\n    intro_rect = string_rendered.get_rect()\r\n    intro_rect.top = text_coord\r\n    intro_rect.x = 110\r\n    screen.blit(string_rendered, intro_rect)\r\n    pygame.display.flip()\r\n\r\n\r\n# обработка ввода\r\ndef start_screen():\r\n    need_input = False\r\n    input_text = ''\r\n    while True:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n            elif need_input is False and event.type == pygame.KEYDOWN:\r\n                if event.key == pygame.K_RETURN:\r\n                    return 'default_level'\r\n            elif need_input and event.type == pygame.KEYDOWN:\r\n                if event.key == pygame.K_RETURN:\r\n                    return input_text\r\n                elif event.key == pygame.K_BACKSPACE:\r\n                    if len(input_text) > 0:\r\n                        input_text = input_text[:-1]\r\n                else:\r\n                    if len(input_text) <= 20:\r\n                        input_text += event.unicode\r\n            elif event.type == pygame.MOUSEBUTTONDOWN:\r\n                if event.pos[0] > 100 and event.pos[0] < 400 and \\\r\n                        event.pos[1] > 300 and event.pos[1] < 350:\r\n                    need_input = True\r\n        print_text(input_text)\r\n        pygame.display.flip()\r\n\r\n\r\nclass PauseImage(pygame.sprite.Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(pause_group)\r\n        self.n = 0\r\n        self.image = load_image('pause.png')\r\n        self.rect = self.image.get_rect().move(pos_x, pos_y)\r\n\r\n    def update(self):\r\n        self.n += 1\r\n        self.image = load_image('on.png' if self.n % 2 == 1 else 'pause.png')\r\n\r\n\r\n# класс пакмена\r\nclass Player(pygame.sprite.Sprite):\r\n\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(player_group, all_sprites)\r\n        self.image = load_image_pacman('pacman.gif')\r\n        self.rect = self.image.get_rect().move(\r\n            tile_width * pos_x, tile_height * pos_y)\r\n        self.x = tile_width * pos_x\r\n        self.y = tile_height * pos_y\r\n        self.score = 0\r\n        self.start_pos = [pos_x, pos_y]\r\n        self.side_tuples = {\r\n            'left': (-1, 0),\r\n            'right': (1, 0),\r\n            'up': (0, -1),\r\n            'down': (0, 1)\r\n        }\r\n\r\n        self.check_tuple = {\r\n            'left': (-1, 0),\r\n            'right': (18, 0),\r\n            'up': (0, -1),\r\n            'down': (0, 18)\r\n        }\r\n\r\n        self.image_list = {\r\n            'left': ['l_0', 'l_1', 'l_2', 'l_3', 'l_4', 'l_5', 'l_6', 'l_7', 'l_0'],\r\n            'right': ['r_0', 'r_1', 'r_2', 'r_3', 'r_4', 'r_5', 'r_6', 'r_7', 'r_0'],\r\n            'up': ['u_0', 'u_1', 'u_2', 'u_3', 'u_4', 'u_5', 'u_6', 'u_7', 'u_0'],\r\n            'down': ['d_0', 'd_1', 'd_2', 'd_3', 'd_4', 'd_5', 'd_6', 'd_7', 'd_0']\r\n        }\r\n\r\n    def new(self):\r\n        self.x = tile_width * self.start_pos[0]\r\n        self.y = tile_height * self.start_pos[1]\r\n        self.rect.x = self.x\r\n        self.rect.y = self.y\r\n\r\n    # проверяет все столкновения\r\n    def collides(self):\r\n        lst = ['vertical', 'horisontal', '1', '2', '3', '4', 'gate']\r\n        collid_lst = pygame.sprite.spritecollideany(self, tiles_group)\r\n        if collid_lst is None or collid_lst.image in [tile_images[_] for _ in lst]:\r\n            return False\r\n        else:\r\n            if collid_lst.image is tile_images['point']:\r\n                self.score += 10\r\n                tile = pygame.sprite.spritecollideany(self, tiles_group)\r\n                tile.image = tile_images['empty']\r\n                return 4\r\n            elif collid_lst.image is tile_images['energo']:\r\n                self.score += 50\r\n                tile = pygame.sprite.spritecollideany(self, tiles_group)\r\n                tile.image = tile_images['empty']\r\n                return 3\r\n            return True\r\n\r\n    # обрабатывает движение пакмена\r\n    def update(self, number, side):\r\n        self.rect = self.rect.move(self.check_tuple[side][0], self.check_tuple[side][1])\r\n        fl = self.collides()\r\n        self.rect = self.rect.move(-self.check_tuple[side][0], -self.check_tuple[side][1])\r\n        if pygame.sprite.spritecollideany(self, hunter_group) is not None:\r\n            print(pygame.sprite.spritecollideany(self, hunter_group))\r\n            check = False\r\n            for hunter in pygame.sprite.spritecollide(self, hunter_group, dokill=False):\r\n                if not hunter.isDead():\r\n                    if hunter.isAttacked():\r\n                        pygame.time.delay(pygame.time.delay(500))\r\n                        hunter.setDead(True)\r\n                        hunter.setAttacked(False)\r\n                        check = True\r\n            if check:\r\n                fl = 2\r\n        if fl and fl not in [2, 3]:\r\n            self.rect = self.rect.move(self.side_tuples[side])\r\n            self.x += self.side_tuples[side][0]\r\n            self.y += self.side_tuples[side][1]\r\n        lst_picture = self.image_list[side]\r\n        self.image = load_image_pacman(lst_picture[number] + '.gif')\r\n        if fl in [2, 3, 4]:\r\n            return fl - 1\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- functions.py	(revision 98092ba1ab41a7022d1b3a38157e2f3f27cf8866)
+++ functions.py	(date 1642955829465)
@@ -440,12 +440,12 @@
                 self.score += 10
                 tile = pygame.sprite.spritecollideany(self, tiles_group)
                 tile.image = tile_images['empty']
-                return 4
+                return 'point'
             elif collid_lst.image is tile_images['energo']:
                 self.score += 50
                 tile = pygame.sprite.spritecollideany(self, tiles_group)
                 tile.image = tile_images['empty']
-                return 3
+                return 'energo'
             return True
 
     # обрабатывает движение пакмена
@@ -453,25 +453,13 @@
         self.rect = self.rect.move(self.check_tuple[side][0], self.check_tuple[side][1])
         fl = self.collides()
         self.rect = self.rect.move(-self.check_tuple[side][0], -self.check_tuple[side][1])
-        if pygame.sprite.spritecollideany(self, hunter_group) is not None:
-            print(pygame.sprite.spritecollideany(self, hunter_group))
-            check = False
-            for hunter in pygame.sprite.spritecollide(self, hunter_group, dokill=False):
-                if not hunter.isDead():
-                    if hunter.isAttacked():
-                        pygame.time.delay(pygame.time.delay(500))
-                        hunter.setDead(True)
-                        hunter.setAttacked(False)
-                        check = True
-            if check:
-                fl = 2
-        if fl and fl not in [2, 3]:
+        if fl:
             self.rect = self.rect.move(self.side_tuples[side])
             self.x += self.side_tuples[side][0]
             self.y += self.side_tuples[side][1]
         lst_picture = self.image_list[side]
         self.image = load_image_pacman(lst_picture[number] + '.gif')
-        if fl in [2, 3, 4]:
-            return fl - 1
+        if fl == 
+        
 
 
Index: game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from functions import *\r\n\r\nevents_sequence, counter, number = ['up'], 1, 0\r\npause = False\r\n\r\n\r\nclass Game:\r\n    def __init__(self, level, score=0, mode=1, lives=3):\r\n        \"\"\"значения mode:\r\n        0 - пауза\r\n        1 - основная игра\r\n        2 - съел точку (пауза)\r\n        3 - съел точку процесс\r\n        4 - съел призрака (пауза)\r\n        5 - уход призрака\r\n        6 - призрак съел пакмена\r\n        \"\"\"\r\n        self.lives = lives\r\n        self.score = score\r\n        self.mode = mode\r\n        grid = load_level(level)\r\n        self.pacman, self.x, self.y, self.pacman_pos, self.points = generate_level(grid)\r\n        self.start_pacman_pos = self.pacman_pos.copy()\r\n        self.hunter_start_pos = []\r\n        self.ghosts = []\r\n        temp = sample(ghostGate, k=4)\r\n        for col in range(4):\r\n            start_pos = x, y = temp[col]\r\n            self.hunter_start_pos.append(start_pos)\r\n            hunter = Hunter(hunter_group, x, y, grid, col)\r\n            self.ghosts.append(hunter)\r\n            all_sprites.add(hunter)\r\n\r\n\r\ndef react(game, side, timers):\r\n    global events_sequence, counter, number, i\r\n    if game.points == 0:\r\n        print('you win')\r\n    result = game.pacman.update(number, side)\r\n    if result == 1:\r\n        for hunter in hunter_group:\r\n            if not hunter.isAttacked() and not hunter.isDead():\r\n                for hunter in hunter_group:\r\n                    hunter.new()\r\n                game.pacman.new()\r\n                events_sequence, counter, number = ['up'], 1, 0\r\n                break\r\n            elif hunter.isAttacked():\r\n                if pygame.sprite.spritecollideany(hunter, player_group) is not None:\r\n                    if not hunter.isDead():\r\n                        hunter.setDead(True)\r\n                        hunter.setAttacked(False)\r\n                        pygame.time.delay(pygame.time.delay(500))\r\n                        counter -= 1\r\n\r\n    elif result == 2:\r\n        for hunter in hunter_group:\r\n            if hunter.isAttacked:\r\n                timers[i].cancel()\r\n            if not hunter.isDead():\r\n                hunter.setAttacked(True)\r\n        pygame.time.delay(pygame.time.delay(500))\r\n        counter -= 1\r\n        i += 1\r\n        timers[i - 1].start()\r\n\r\n    elif result == 3:\r\n        game.points -= 1\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    pygame.init()\r\n    size = width, height = 500, 500\r\n    screen = pygame.display.set_mode(size)\r\n    game = Game('default_level.txt')\r\n    i = 0\r\n\r\n\r\n    def revival():\r\n        for hunter in hunter_group:\r\n            hunter.attacked = False\r\n\r\n\r\n    timer1 = threading.Timer(10, revival)\r\n    timer2 = threading.Timer(10, revival)\r\n    timer3 = threading.Timer(10, revival)\r\n    timer4 = threading.Timer(10, revival)\r\n    timers = [timer1, timer2, timer3, timer4]\r\n\r\n    running = True\r\n    player = None\r\n    level = 'default_level.txt'\r\n    count1 = count2 = 26\r\n    clock = pygame.time.Clock()\r\n    FPS = 60\r\n    change_values = {\r\n        pygame.K_LEFT: 'left',\r\n        pygame.K_RIGHT: 'right',\r\n        pygame.K_UP: 'up',\r\n        pygame.K_DOWN: 'down'\r\n    }\r\n\r\n    while running:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n                break\r\n            if event.type == pygame.KEYDOWN:\r\n                if event.key == 27:\r\n                    pause = bool(1 - pause)\r\n                if event.key in change_values.keys() and len(events_sequence) <= 1:\r\n                    events_sequence.append(change_values[event.key])\r\n        if counter == 0:\r\n            game.pacman_pos = [int(game.pacman.x / 18), int(game.pacman.y / 18)]\r\n            events_sequence = [events_sequence[1]] if len(events_sequence) > 1 else events_sequence\r\n        if not pause:\r\n            if game.mode in [1, 3, 5]:\r\n                react(game, events_sequence[0], timers)\r\n            if len(events_sequence) > 0:\r\n                counter = (counter + 1) % 18\r\n                number = (number + 1) % 9\r\n            for hunter in hunter_group:\r\n                hunter.move((game.pacman_pos[0], game.pacman_pos[1]))\r\n        all_sprites.draw(screen)\r\n        tiles_group.draw(screen)\r\n        base_group.draw(screen)\r\n        player_group.draw(screen)\r\n        hunter_group.draw(screen)\r\n        pygame.display.flip()\r\n        clock.tick(FPS)\r\n    terminate()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- game.py	(revision 98092ba1ab41a7022d1b3a38157e2f3f27cf8866)
+++ game.py	(date 1642955547718)
@@ -36,7 +36,9 @@
     global events_sequence, counter, number, i
     if game.points == 0:
         print('you win')
-    result = game.pacman.update(number, side)
+    game.pacman.update(number, side)
+    if result is not None and result != 3:
+        print(result)
     if result == 1:
         for hunter in hunter_group:
             if not hunter.isAttacked() and not hunter.isDead():
